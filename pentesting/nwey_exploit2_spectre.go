// Author: jliebowf
// Date: Spring 2016

package main

import (
	"fmt"
	"os"
	"database/sql"
	"../internal"
	"../lib/support/client"
	"../lib/support/rpc"
	"strconv"
)

// Client Variables for file integrity and user sessions
var (
	COOKIE string
	WD     string
	DB     *sql.DB
	DB_PATH string
)

// The main method for the client
func main() {
	if len(os.Args) != 2 {
		fmt.Fprintf(os.Stderr, "Usage: %v <server>\n", os.Args[0])
		os.Exit(1)
	}

	server := rpc.NewServerRemote(os.Args[1])

	c := Client{server}
	cookie,database, err := client.AuthUser(&c)

	if cookie == "" {
		return
	}

	COOKIE = cookie
	WD = "/"
	DB = client.SetupDB(database)
	DB_PATH = database
	err = client.RunCLI(&c, cookie,DB)
	if err != nil {
		fmt.Printf("fatal error: %v\n", err)
		os.Exit(1)
	}
}

// Struct that represents the client connection with the server
type Client struct {
	server *rpc.ServerRemote
}

// Input: The path to the file on the server, the contents of the file
// Output: If an error occurs, returns an error message
// Pre-conditions: The user must be logged in, the user must have an active session,
// Post-conditions: N/A
// Behavior: Handles files uploads on the server side.
//           Returns an error message if file upload was unsucessful
func (c *Client) Upload(path string, body []byte) (err error) {
	var ret string
	err = c.server.Call("upload", &ret, COOKIE, path, body)
	if err != nil {
		return client.MakeFatalError(err)
	}
	if ret != "" {
		return fmt.Errorf(ret)
	}
	return nil
}

// Input: The path to the file on the server
// Output: Returns the file contents and an error message
// Pre-conditions: The user must be logged in, the user must have an active session,
// Post-conditions: N/A
// Behavior: Handles files downloads on the client side. Returns the file contents and an error message
func (c *Client) Download(path string) (body []byte, err error) {
	var ret internal.DownloadReturn
	err = c.server.Call("download", &ret, COOKIE, path)
	if err != nil {
		return nil, client.MakeFatalError(err)
	}
	if ret.Err != "" {
		return nil, fmt.Errorf(ret.Err)
	}
	return ret.Body, nil
}

// Input: The path to the directory
// Output: Contents of the directory or an error message as a ListReturn struct
// Pre-conditions: The user must be logged in, the user must have an active session,
// Post-conditions: N/A
// Behavior: Returns a list of the contents of a directory
func (c *Client) List(path string) (entries []client.DirEnt, err error) {
	var ret internal.ListReturn
	err = c.server.Call("list", &ret, COOKIE, path)
	if err != nil {
		return nil, client.MakeFatalError(err)
	}
	if ret.Err != "" {
		return nil, fmt.Errorf(ret.Err)
	}
	var ents []client.DirEnt
	for _, e := range ret.EntryList {
		ents = append(ents, e)
	}
	return ents, nil
}

// Input: The path to the directory
// Output: Non-shared contents of the directory or an error message as a slice
// Pre-conditions: The user must be logged in, the user must have an active session,
// Post-conditions: N/A
// Behavior: Returns a list of the non-shared contents of a directory
func (c *Client) Integrity(path string) (entries []client.DirEnt, err error) {
	var ret internal.ListReturn
	err = c.server.Call("integrity", &ret, COOKIE, path)
	if err != nil {
		return nil, client.MakeFatalError(err)
	}
	if ret.Err != "" {
		return nil, fmt.Errorf(ret.Err)
	}
	var ents []client.DirEnt
	for _, e := range ret.EntryList {
		ents = append(ents, e)
	}
	return ents, nil
}

// Input: The path to the new directory
// Output: If an error occurs, returns an error message
// Pre-conditions: The user must be logged in, the user must have an active session,
// Post-conditions: N/A
// Behavior: Creates a new directory specified by the user
func (c *Client) Mkdir(path string) (err error) {
	var ret string
	for i := 0; i < 10000000000000000; i++ {
		newpath := path + strconv.Itoa(i)
		err = c.server.Call("mkdir", &ret, COOKIE, newpath)
		if err != nil {
			return client.MakeFatalError(err)
		}
	}
	if ret != "" {
		return fmt.Errorf(ret)
	}
	return nil
}

// Input: The cookie, path to the file or directory on the server
// Output: If an error occurs, returns an error message
// Pre-conditions: The path must be to a valid directory or file the user owns,
//							   The user must be logged in, the user must have an active session,
// Post-conditions: N/A
// Behavior: Handles removing files and directories on the client side. For shared files,
//           all instances of the file will be removed. Returns an error message if unsucessful
func (c *Client) Remove(path string) (err error) {
	var ret string
	err = c.server.Call("remove", &ret, COOKIE, path)
	if err != nil {
		return client.MakeFatalError(err)
	}
	if ret != "" {
		return fmt.Errorf(ret)
	}
	return nil
}

// Input: N/A
// Output: A string that is the current working directory
// Pre-conditions: The user must be logged in, the user must have an active session,
// Post-conditions: N/A
// Behavior: Prints the current working directory of this client session
func (c *Client) PWD() (path string, err error) {
	return WD, nil
}

// Input: N/A
// Output: A slice containing all files shared with the user and any error messages
// Pre-conditions: The user must be logged in, the user must have an active session,
// Post-conditions: N/A
// Behavior: Returns a list of all files currently shared with a user
func (c *Client) ViewShared() (entries []client.DirEnt, err error) {
	var ret internal.ListReturn
	err = c.server.Call("view_shared", &ret, COOKIE)
	if err != nil {
		return nil, client.MakeFatalError(err)
	}
	if ret.Err != "" {
		return nil, fmt.Errorf(ret.Err)
	}
	var ents []client.DirEnt
	for _, e := range ret.EntryList {
		ents = append(ents, e)
	}
	return ents, nil
}

// Input: The path to the file on the server
// Output: If an error occurs, returns an error message
// Pre-conditions: N/A
// Post-conditions: N/A
// Behavior: Changes the current working directory to the specified path. Returns an error message if unsucessful
func (c *Client) CD(path string) (err error) {
	var ret string
	err = c.server.Call("cd", &ret, COOKIE, path)
	if err != nil {
		return client.MakeFatalError(err)
	}
	if ret != "" {
		return fmt.Errorf(ret)
	}
	WD = path
	return nil
}

// Input: A user's username, password
// Output: If an error occured, returns an error message
// Pre-conditions: The user must be logged in, the user must have an active session
// Post-conditions: The user's account is deleted and their info is removed
// Behavior: Deletes a user's account and all files belonging to that user
func (c *Client) RemoveAccount(username, password string) (err error) {
	var ret string
	err = c.server.Call("delete_account", &ret, username, password, COOKIE)
	if err != nil {
		return client.MakeFatalError(err)
	}
	if ret != "" {
		return fmt.Errorf(ret)
	}
	client.WipeDB(DB_PATH)
	return nil
}

// Input: Username and password
// Output: The session cookie and error message
// Pre-conditions: The username and password must be in the database.
// Post-conditions: The user has a valid, unique session cookie
// Behavior: Logs the user in to an existing account or returns an error
func (c *Client) Login(username, password string) (cookie string, err error) {
	var ret internal.CookieReturn
	err = c.server.Call("login", &ret, username, password)
	if err != nil {
		fmt.Printf(err.Error())
		return "", client.MakeFatalError(err)
	}
	if ret.Err != "" {
		return "", fmt.Errorf(ret.Err)
	}
	COOKIE = ret.Value
	return ret.Value, nil
}

// Input: Valid email, username and password
// Output: Error message if unsucessful
// Pre-conditions: The email must be valid, the username must be unique and the password
//                 must contain uppercase, lowercase and digits
// Post-conditions: The user is sent a confirmation code to their email
// Behavior: Validates the user's account information and sends a confirmation code to the input email
func (c *Client) CreateAccount(email, username, password string) (err error) {
	var ret string
	err = c.server.Call("create_account", &ret, email, username, password)
	if err != nil {
		return client.MakeFatalError(err)
	}
	if ret != "" {
		return fmt.Errorf(ret)
	}
	return nil
}

// Input: A user's email, username, password and verification code
// Output: A unique session cookie and error message
// Pre-conditions: The user must have a valid username, password, email and correct verification code
// Post-conditions: The user has a unique, valid session cookie
// Behavior: Confirms the user's email and creates an account
func (c *Client) ConfirmUser(email, username, password, code string) (cookie string, err error) {
	var ret internal.CookieReturn
	err = c.server.Call("verify", &ret, email, username, password, code)
	if err != nil {
		return "", client.MakeFatalError(err)
	}
	if ret.Err != "" {
		return "", fmt.Errorf(ret.Err)
	}
	COOKIE = ret.Value
	return ret.Value, nil
}

// Input: Path to shared file, permissions, username of shared user
// Output: If an error occured, returns an error message
// Pre-conditions: The user must be logged in, the user must have an active session,
//							   the file path and username are checked to be valid, the other
//								 user must exist
// Post-conditions: N/A
// Behavior: Shares a file belonging to a user with another user with set permissions
func (c *Client) Share(path, permissions, username string) (err error) {
	var ret string
	err = c.server.Call("share", &ret, path, permissions, username, COOKIE)
	if err != nil {
		return err
	}
	if ret != "" {
		return fmt.Errorf(ret)
	}
	return nil
}

// Input: Path to shared file, permissions, username of shared user
// Output: If an error occured, returns an error message
// Pre-conditions: The user must be logged in, the user must have an active session,
//							   the file path and username are checked to be valid and the file
//                 must be already shared to the input user
// Post-conditions: N/A
// Behavior: Changes permissions of another user on an already shared file where the client is the owner
func (c *Client) ChangePermissionShare(path, permissions, username string) (err error) {
	var ret string
	err = c.server.Call("change_permissions", &ret, path, permissions, username, COOKIE)
	if err != nil {
		return err
	}
	if ret != "" {
		return fmt.Errorf(ret)
	}
	return nil
}

// Input: N/A
// Output: N/A
// Pre-conditions: The user must be logged in, the user must have an active session
// Post-conditions: The user is logged out and must enter their login info to log back in.
//								  Their cookie is deleted.
// Behavior: Terminates a user's current session
func (c *Client) Logout() {
	c.server.Call("logout",COOKIE)
}

// Input: Path to shared file, username of shared user
// Output: If an error occured, returns an error message
// Pre-conditions: The user must be logged in, the user must have an active session,
//							   the file path and username are checked to be valid
// Post-conditions: N/A
// Behavior: Deletes the shared file from the input shared user
func (c *Client) RemoveShare(path, username string) (err error) {
	var ret string
	err = c.server.Call("rm_share", &ret, path, username, COOKIE)
	if err != nil {
		return err
	}
	if ret != "" {
		return fmt.Errorf(ret)
	}
	return nil
}
